import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  TransactionInstruction,
  LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import { BN } from '@coral-xyz/anchor';
import { POKER_PROGRAM_ID, SOLANA_RPC_URL, COMMITMENT } from './config';

// IDL Type (will be generated by Anchor, this is a manual version)
// We just use the Idl interface directly from Anchor

export interface TournamentEscrow {
  admin: PublicKey;
  tournamentId: string;
  buyIn: BN;
  rakePercentage: number;
  totalPot: BN;
  rakeAmount: BN;
  playersJoined: number;
  maxPlayers: number;
  status: number;
  playerAddresses: PublicKey[];
  winner: PublicKey | null;
  bump: number;
}

export interface AdminConfig {
  admin: PublicKey;
  defaultRakePercentage: number;
  totalRakeCollected: BN;
  bump: number;
}

export enum TournamentStatus {
  Waiting = 0,
  InProgress = 1,
  Completed = 2,
  Cancelled = 3,
}

export class PokerProgramSDK {
  connection: Connection;
  programId: PublicKey;

  constructor(rpcUrl?: string) {
    this.connection = new Connection(rpcUrl || SOLANA_RPC_URL, COMMITMENT);
    this.programId = POKER_PROGRAM_ID;
  }

  /**
   * Derive PDA for admin config
   */
  async getAdminConfigPDA(): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('admin_config')],
      this.programId
    );
  }

  /**
   * Derive PDA for tournament escrow
   */
  async getTournamentEscrowPDA(tournamentId: string): Promise<[PublicKey, number]> {
    return PublicKey.findProgramAddressSync(
      [Buffer.from('tournament'), Buffer.from(tournamentId)],
      this.programId
    );
  }

  /**
   * Initialize admin configuration (one-time setup)
   */
  async initializeAdmin(
    adminWallet: PublicKey,
    defaultRakePercentage: number
  ): Promise<Transaction> {
    const [adminConfigPDA] = await this.getAdminConfigPDA();

    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: adminWallet, isSigner: true, isWritable: true },
        { pubkey: adminConfigPDA, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.programId,
      data: this.encodeInitializeAdmin(defaultRakePercentage),
    });

    const transaction = new Transaction().add(instruction);
    return transaction;
  }

  /**
   * Create a new tournament
   */
  async initializeTournament(
    adminWallet: PublicKey,
    tournamentId: string,
    buyInSol: number,
    rakePercentage: number
  ): Promise<Transaction> {
    const [tournamentPDA] = await this.getTournamentEscrowPDA(tournamentId);
    const buyInLamports = Math.floor(buyInSol * LAMPORTS_PER_SOL);

    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: adminWallet, isSigner: true, isWritable: true },
        { pubkey: tournamentPDA, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.programId,
      data: this.encodeInitializeTournament(buyInLamports, rakePercentage, tournamentId),
    });

    const transaction = new Transaction().add(instruction);
    return transaction;
  }

  /**
   * Player joins tournament
   */
  async joinTournament(
    playerWallet: PublicKey,
    tournamentId: string
  ): Promise<Transaction> {
    const [tournamentPDA] = await this.getTournamentEscrowPDA(tournamentId);

    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: playerWallet, isSigner: true, isWritable: true },
        { pubkey: tournamentPDA, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.programId,
      data: this.encodeJoinTournament(),
    });

    const transaction = new Transaction().add(instruction);
    return transaction;
  }

  /**
   * Distribute prizes to winner
   */
  async distributePrizes(
    adminWallet: PublicKey,
    tournamentId: string,
    winnerWallet: PublicKey
  ): Promise<Transaction> {
    const [tournamentPDA] = await this.getTournamentEscrowPDA(tournamentId);

    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: adminWallet, isSigner: true, isWritable: true },
        { pubkey: tournamentPDA, isSigner: false, isWritable: true },
        { pubkey: winnerWallet, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.programId,
      data: this.encodeDistributePrizes(winnerWallet),
    });

    const transaction = new Transaction().add(instruction);
    return transaction;
  }

  /**
   * Admin withdraws rake
   */
  async withdrawRake(
    adminWallet: PublicKey,
    tournamentId: string
  ): Promise<Transaction> {
    const [tournamentPDA] = await this.getTournamentEscrowPDA(tournamentId);
    const [adminConfigPDA] = await this.getAdminConfigPDA();

    const instruction = new TransactionInstruction({
      keys: [
        { pubkey: adminWallet, isSigner: true, isWritable: true },
        { pubkey: tournamentPDA, isSigner: false, isWritable: true },
        { pubkey: adminConfigPDA, isSigner: false, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: this.programId,
      data: this.encodeWithdrawRake(),
    });

    const transaction = new Transaction().add(instruction);
    return transaction;
  }

  /**
   * Fetch tournament escrow account data
   */
  async getTournamentEscrow(tournamentId: string): Promise<TournamentEscrow | null> {
    const [tournamentPDA] = await this.getTournamentEscrowPDA(tournamentId);
    
    try {
      const accountInfo = await this.connection.getAccountInfo(tournamentPDA);
      if (!accountInfo) return null;

      // Parse account data (simplified - in production use Anchor's deserialization)
      return this.parseTournamentEscrow(accountInfo.data);
    } catch (error) {
      console.error('Error fetching tournament escrow:', error);
      return null;
    }
  }

  /**
   * Fetch admin config
   */
  async getAdminConfig(): Promise<AdminConfig | null> {
    const [adminConfigPDA] = await this.getAdminConfigPDA();
    
    try {
      const accountInfo = await this.connection.getAccountInfo(adminConfigPDA);
      if (!accountInfo) return null;

      return this.parseAdminConfig(accountInfo.data);
    } catch (error) {
      console.error('Error fetching admin config:', error);
      return null;
    }
  }

  // Encoding methods (simplified - in production use Anchor's IDL)
  private encodeInitializeAdmin(rakePercentage: number): Buffer {
    // Instruction discriminator + data
    const buffer = Buffer.alloc(10);
    buffer.writeUInt8(0, 0); // instruction index
    buffer.writeUInt16LE(rakePercentage, 1);
    return buffer;
  }

  private encodeInitializeTournament(
    buyIn: number,
    rakePercentage: number,
    tournamentId: string
  ): Buffer {
    const idBuffer = Buffer.from(tournamentId);
    const buffer = Buffer.alloc(11 + idBuffer.length);
    buffer.writeUInt8(1, 0); // instruction index
    buffer.writeBigUInt64LE(BigInt(buyIn), 1);
    buffer.writeUInt16LE(rakePercentage, 9);
    idBuffer.copy(buffer, 11);
    return buffer;
  }

  private encodeJoinTournament(): Buffer {
    const buffer = Buffer.alloc(1);
    buffer.writeUInt8(2, 0); // instruction index
    return buffer;
  }

  private encodeDistributePrizes(winner: PublicKey): Buffer {
    const buffer = Buffer.alloc(33);
    buffer.writeUInt8(3, 0); // instruction index
    winner.toBuffer().copy(buffer, 1);
    return buffer;
  }

  private encodeWithdrawRake(): Buffer {
    const buffer = Buffer.alloc(1);
    buffer.writeUInt8(4, 0); // instruction index
    return buffer;
  }

  // Parsing methods (simplified - in production use Anchor's deserialization)
  private parseTournamentEscrow(data: Buffer): TournamentEscrow {
    // Skip discriminator (8 bytes)
    let offset = 8;
    
    const admin = new PublicKey(data.slice(offset, offset + 32));
    offset += 32;
    
    // Parse tournament ID (length + string)
    const idLength = data.readUInt32LE(offset);
    offset += 4;
    const tournamentId = data.slice(offset, offset + idLength).toString();
    offset += idLength;
    
    const buyIn = new BN(data.readBigUInt64LE(offset));
    offset += 8;
    
    const rakePercentage = data.readUInt16LE(offset);
    offset += 2;
    
    const totalPot = new BN(data.readBigUInt64LE(offset));
    offset += 8;
    
    const rakeAmount = new BN(data.readBigUInt64LE(offset));
    offset += 8;
    
    const playersJoined = data.readUInt8(offset);
    offset += 1;
    
    const maxPlayers = data.readUInt8(offset);
    offset += 1;
    
    const status = data.readUInt8(offset);
    offset += 1;
    
    const playerAddresses: PublicKey[] = [];
    for (let i = 0; i < 6; i++) {
      playerAddresses.push(new PublicKey(data.slice(offset, offset + 32)));
      offset += 32;
    }
    
    // Parse optional winner
    const hasWinner = data.readUInt8(offset);
    offset += 1;
    const winner = hasWinner ? new PublicKey(data.slice(offset, offset + 32)) : null;
    offset += 32;
    
    const bump = data.readUInt8(offset);
    
    return {
      admin,
      tournamentId,
      buyIn,
      rakePercentage,
      totalPot,
      rakeAmount,
      playersJoined,
      maxPlayers,
      status,
      playerAddresses,
      winner,
      bump,
    };
  }

  private parseAdminConfig(data: Buffer): AdminConfig {
    let offset = 8; // Skip discriminator
    
    const admin = new PublicKey(data.slice(offset, offset + 32));
    offset += 32;
    
    const defaultRakePercentage = data.readUInt16LE(offset);
    offset += 2;
    
    const totalRakeCollected = new BN(data.readBigUInt64LE(offset));
    offset += 8;
    
    const bump = data.readUInt8(offset);
    
    return {
      admin,
      defaultRakePercentage,
      totalRakeCollected,
      bump,
    };
  }
}

// Singleton instance
export const pokerProgram = new PokerProgramSDK();

